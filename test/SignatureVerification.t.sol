// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import "../src/Registration.sol";
import "../src/OracleManager.sol";
import "./utils/KYCTestHelper.sol";
import {MessageHashUtils} from "@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol";
import {ECDSA} from "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";

/**
 * @title SignatureVerificationTest
 * @notice Comprehensive test suite for KYC attestation signature generation and verification.
 * 
 * This test ensures that signatures generated by the frontend (via keccak256(abi.encode(...)))
 * and signed with personal_sign (or equivalent) can be verified on-chain correctly.
 * 
 * The test flow matches the expected frontend behavior:
 * 1. Frontend builds payload: keccak256(abi.encode(chainId, participant, role, metaDataHash, timestamp, nonce))
 * 2. Frontend hashes to eth_sign format: toEthSignedMessageHash(payload)
 * 3. Frontend calls personal_sign with the message (which applies the prefix again)
 * 4. Contract recovers signer and verifies it matches the KYC signer
 */
contract SignatureVerificationTest is Test {
    using MessageHashUtils for bytes32;
    using ECDSA for bytes32;

    Registration reg;
    KYCTestHelper kycHelper;
    address owner;
    address oracleSigner;
    uint256 oraclePrivateKey;

    function setUp() public {
        owner = makeAddr("owner");
        (oracleSigner, oraclePrivateKey) = makeAddrAndKey("oracle");

        vm.startPrank(owner);
        reg = new Registration();
        reg.addKYCSigner(oracleSigner);
        vm.stopPrank();

        kycHelper = new KYCTestHelper(reg, owner);
    }

    /**
     * @notice Test that a manually constructed signature (matching frontend keccak256 hashing)
     * can be verified on-chain for KYC attestation.
     */
    function testKycAttestationSignatureVerification() public {
        address participant = makeAddr("farmer");
        string memory metaDataHash = "ipfs://QmTestMetadataHash123";
        uint256 timestamp = block.timestamp;
        uint256 nonce = 0;
        Registration.Role role = Registration.Role.FARMER;

        // Step 1: Register participant
        vm.prank(participant);
        reg.registerParticipant(role, metaDataHash);

        // Step 2: Build the payload hash exactly as the frontend should:
        // keccak256(abi.encode(chainId, participant, role, metaDataHash, timestamp, nonce))
        bytes32 payloadHash = keccak256(abi.encode(
            block.chainid,
            participant,
            role,
            keccak256(bytes(metaDataHash)),
            timestamp,
            nonce
        ));

        // Step 3: Convert to eth_sign format (adds "\x19Ethereum Signed Message:\n32" prefix)
        bytes32 ethSignedHash = payloadHash.toEthSignedMessageHash();

        // Step 4: Sign with oracle private key
        // This simulates: personal_sign(payloadHash, oracleSigner) in MetaMask
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(oraclePrivateKey, ethSignedHash);
        bytes memory signature = abi.encodePacked(r, s, v);

        // Step 5: Build KYC attestation params and call contract
        Registration.KYCAttestationParams memory params = Registration.KYCAttestationParams({
            participant: participant,
            role: role,
            metaDataHash: metaDataHash,
            timestamp: timestamp,
            nonce: nonce,
            signature: signature
        });

        // Step 6: Call kycAttestation (only oracle signer can call)
        vm.prank(oracleSigner);
        reg.kycAttestation(params);

        // Step 7: Verify KYC status updated
        assertTrue(reg.isKycVerified(participant), "Participant should be KYC verified after attestation");
        assertTrue(
            reg.hasRole(participant, Registration.Role.FARMER),
            "Participant should have FARMER role"
        );
    }

    /**
     * @notice Test that using an incorrect oracle private key (wrong signer) fails verification.
     * This ensures the signature validation is strict.
     */
    function testKycAttestationWithWrongSignerFails() public {
        address participant = makeAddr("farmer");
        (,uint256 wrongPrivateKey) = makeAddrAndKey("wrongKey");

        string memory metaDataHash = "ipfs://QmTest";
        uint256 timestamp = block.timestamp;
        uint256 nonce = 0;

        vm.prank(participant);
        reg.registerParticipant(Registration.Role.FARMER, metaDataHash);

        // Build payload as frontend would
        bytes32 payloadHash = keccak256(abi.encode(
            block.chainid,
            participant,
            Registration.Role.FARMER,
            keccak256(bytes(metaDataHash)),
            timestamp,
            nonce
        ));
        bytes32 ethSignedHash = payloadHash.toEthSignedMessageHash();

        // Sign with wrong oracle key
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(wrongPrivateKey, ethSignedHash);
        bytes memory signature = abi.encodePacked(r, s, v);

        Registration.KYCAttestationParams memory params = Registration.KYCAttestationParams({
            participant: participant,
            role: Registration.Role.FARMER,
            metaDataHash: metaDataHash,
            timestamp: timestamp,
            nonce: nonce,
            signature: signature
        });

        // Attempt to attest with wrong signer (should fail)
        vm.prank(oracleSigner);
        vm.expectRevert("Invalid KYC signer");
        reg.kycAttestation(params);
    }

    /**
     * @notice Test that signature with stale timestamp is rejected.
     */
    function testKycAttestationWithStaleTimestampFails() public {
        address participant = makeAddr("farmer");
        string memory metaDataHash = "ipfs://QmTest";
        Registration.Role role = Registration.Role.FARMER;

        vm.prank(participant);
        reg.registerParticipant(role, metaDataHash);

        // Advance time 11 minutes, then use current time (which is 11 minutes in the future)
        // to ensure the original timestamp is now stale
        vm.warp(block.timestamp + 11 minutes);
        uint256 staleTimestamp = block.timestamp - 11 minutes; // Original time, now stale
        uint256 nonce = 0;

        bytes32 payloadHash = keccak256(abi.encode(
            block.chainid,
            participant,
            role,
            keccak256(bytes(metaDataHash)),
            staleTimestamp,
            nonce
        ));
        bytes32 ethSignedHash = payloadHash.toEthSignedMessageHash();

        (uint8 v, bytes32 r, bytes32 s) = vm.sign(oraclePrivateKey, ethSignedHash);
        bytes memory signature = abi.encodePacked(r, s, v);

        Registration.KYCAttestationParams memory params = Registration.KYCAttestationParams({
            participant: participant,
            role: role,
            metaDataHash: metaDataHash,
            timestamp: staleTimestamp,
            nonce: nonce,
            signature: signature
        });

        vm.prank(oracleSigner);
        vm.expectRevert("Attestation expired");
        reg.kycAttestation(params);
    }

    /**
     * @notice Test that using the kycHelper (which generates correct params) works end-to-end.
     * This verifies backward compatibility with existing test utilities.
     */
    function testKycHelperGeneratesValidSignature() public {
        address participant = makeAddr("participant");
        Registration.Role role = Registration.Role.FARMER;
        string memory metaDataHash = "ipfs://QmHelper";

        vm.prank(participant);
        reg.registerParticipant(role, metaDataHash);

        // Use kycHelper to generate attestation params (should match frontend signature generation)
        Registration.KYCAttestationParams memory params = kycHelper.createKYCParams(
            participant,
            role,
            metaDataHash,
            block.timestamp,
            0
        );

        // Verify that the generated signature is valid
        vm.prank(oracleSigner);
        reg.kycAttestation(params);

        assertTrue(
            reg.isKycVerified(participant),
            "Participant should be KYC verified using kycHelper-generated signature"
        );
    }
}
